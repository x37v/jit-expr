#N canvas 2 72 1362 694 12;
#X obj 203 46 xnor/expr;
#X obj 209 73 xnor/expr~;
#X obj 316 66 xnor/fexpr~;
#X floatatom 760 121 5 0 0 0 - - -, f 5;
#X floatatom 760 209 5 0 0 0 - - -, f 5;
#X floatatom 804 208 5 0 0 0 - - -, f 5;
#X text 21 78 Online documentation: http://yadegari.org/xnor/expr/xnor/expr.html
, f 62;
#X text 45 457 - $x#[n]: an input audio sample from inlet # indexed
by 'n';
#X text 45 476 - $y#[n]: an output audio sample from outlet # indexed
by 'n', f 61;
#X text 80 501 where 'n' for $x# has to satisfy: 0 => n >= -vector
size;
#X text 79 520 and 'n' for $y# has to satisfy: -1 => n >= -vector size
;
#X text 21 113 - [xnor/expr]: used for evaluation of control data expressions
, f 62;
#X text 45 399 - $v#: an audio signal vector/block, f 59;
#X text 45 297 - $i#: an integer, f 59;
#X text 45 316 - $f#: a float, f 59;
#X text 45 335 - $s#: a symbol (used to define arrays), f 59;
#X obj 760 147 xnor/expr $f1 + 1 \; $f1 - 1 \; $f1 * 2;
#X floatatom 848 208 5 0 0 0 - - -, f 5;
#X text 385 48 Version 0.55;
#N canvas 273 26 812 549 Arrays 0;
#N canvas 0 50 450 300 (subpatch) 0;
#X array array1 10 float 0;
#X coords 0 10 9 0 220 130 1 0 0;
#X restore 537 143 graph;
#X floatatom 187 341 0 0 9 0 - - -;
#X floatatom 187 398 0 0 0 0 - - -;
#X obj 187 370 xnor/expr $s2[$f1];
#X msg 275 342 symbol array1;
#X obj 532 39 loadbang;
#X floatatom 137 135 5 0 9 0 - - -, f 5;
#X floatatom 137 211 5 0 0 0 - - -, f 5;
#X obj 137 172 xnor/expr array1[$f1];
#X msg 532 71 \; array1 0 1 4 2 8 5 6 1 4 2 8;
#X text 30 87 For instance:;
#X obj 275 313 loadbang;
#X text 32 265 A symbol inlet - defined as $s# (# being the inlet number)
- is used to receive array names.;
#X floatatom 585 430 0 0 100 0 - - -;
#X obj 585 311 vsl 20 100 0 10 0 0 empty empty empty 0 -9 0 10 -262144
-1 -1 0 1;
#X obj 585 461 xnor/expr array1[1] = $f1;
#X text 27 23 The xnor/expr family of objects can read values from
array (without interpolation) and also write to them. The syntax is
arrayname[index].;
#X text 263 165 input is the index to read from the array, f 21;
#X text 206 461 You can set values to an array index with "="* as in:
;
#X text 524 493 *a.k.a. "store function";
#X connect 1 0 3 0;
#X connect 3 0 2 0;
#X connect 4 0 3 1;
#X connect 5 0 9 0;
#X connect 6 0 8 0;
#X connect 8 0 7 0;
#X connect 11 0 4 0;
#X connect 13 0 15 0;
#X connect 14 0 13 0;
#X restore 803 352 pd Arrays;
#X text 556 182 Basic examples:;
#X text 748 322 Further details:;
#N canvas 168 109 950 501 Dealing_with_"\$0" 0;
#X obj 623 138 xnor/expr $s2[$f1];
#X obj 711 107 symbol \$0-x;
#X floatatom 623 112 5 0 99 0 - - -, f 5;
#X floatatom 623 166 5 0 0 0 - - -, f 5;
#X obj 711 84 loadbang;
#N canvas 0 50 450 300 (subpatch) 0;
#X array \$0-x 100 float 1;
#A 0 -0.720016 -0.706683 -0.693349 -0.680016 -0.666682 -0.653348 -0.640015
-0.625014 -0.610014 -0.595014 -0.580013 -0.565013 -0.550013 -0.535012
-0.520012 -0.505012 -0.490011 -0.475011 -0.460011 -0.44501 -0.43001
-0.415009 -0.400009 -0.385009 -0.370008 -0.355008 -0.340008 -0.325007
-0.310007 -0.295007 -0.280006 -0.264006 -0.248006 -0.232005 -0.216005
-0.200005 -0.184004 -0.168004 -0.152003 -0.136003 -0.120003 -0.106669
-0.0933355 -0.0800018 -0.0666682 -0.0533346 -0.0400009 -0.0266673 -0.0133336
-3.10441e-10 0.0133336 0.0266673 0.0400009 0.0533346 0.0666682 0.0800018
0.0933355 0.106669 0.120003 0.133336 0.14667 0.160004 0.173337 0.186671
0.200005 0.213338 0.226672 0.240005 0.253339 0.266673 0.280006 0.29715
0.314293 0.331436 0.348579 0.365723 0.382866 0.400009 0.413343 0.426676
0.44001 0.453344 0.466677 0.480011 0.500011 0.520012 0.540012 0.560013
0.570013 0.580013 0.590014 0.600014 0.620014 0.640015 0.660015 0.680016
0.680016 0.720016 0.720016 0.720016;
#X coords 0 1 99 -1 200 150 1 0 0;
#X restore 224 216 graph;
#X text 22 139 Also \, the '-' character is used as the subtraction
operator \, so '\$0-x' is interpreted as "Id number" minus 'x'.;
#X obj 82 406 xnor/expr \$0-x[$f1];
#X floatatom 82 372 5 0 99 0 - - -, f 5;
#X floatatom 82 442 5 0 0 0 - - -, f 5;
#X obj 767 406 value x\$0;
#X obj 809 374 value y_\$0;
#X obj 590 354 xnor/expr x\$0 \; y_\$0;
#X msg 767 376 1.3;
#X msg 809 344 4.7;
#X obj 767 304 loadbang;
#X obj 590 323 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X floatatom 650 403 5 0 0 0 - - -, f 5;
#X floatatom 590 403 5 0 0 0 - - -, f 5;
#X text 499 37 A solution for such issues is to send the table name
as a symbol:;
#X text 511 231 But a simpler practice is to just avoid these issues
by having '\$0' after a symbol character \, such as:;
#X text 21 27 '\$0' - the patch ID number used to force locality in
Pd - may be used in the definition of arrays or variables names. But
it is important to note the restrictions of adopting the C-style expression
syntax \, where variables cannot start with a number \, so '\$0x' is
an illegal character as Pd sees it as starting with a number. in this
case \, the object won't load!;
#X text 209 399 It loads \, but the symbol is interpreted as "\$0 -
x" \, so it is not a valid symbol character and not a table name -
see Pd window for error., f 40;
#X text 690 166 <= works now;
#X connect 0 0 3 0;
#X connect 1 0 0 1;
#X connect 2 0 0 0;
#X connect 4 0 1 0;
#X connect 7 0 9 0;
#X connect 8 0 7 0;
#X connect 12 0 18 0;
#X connect 12 1 17 0;
#X connect 13 0 10 0;
#X connect 14 0 11 0;
#X connect 15 0 13 0;
#X connect 15 0 14 0;
#X connect 16 0 12 0;
#X restore 803 406 pd Dealing_with_"\$0";
#X text 21 48 By Shahrokh Yadegari;
#X text 21 197 - [xnor/fexpr~]: used for evaluation of signal expressions
on sample level data (i.e. \, filter design) - very cpu intensive!
, f 62;
#X text 21 244 Input variables types for [xnor/expr] \, [xnor/expr~]
and [xnor/fexpr~] are: integers \, floats and symbols \, specified
as follows where the '#' stands for the inlet number:, f 62;
#X text 21 362 The [xnor/expr~] object has an exclusive input variable
type for signal vectors \, defined as:, f 62;
#X text 21 428 The [xnor/fexpr~] object has exclusive variable types
\, defined as:, f 62;
#X text 21 140 - [xnor/expr~]: used for evaluation of audio signal
expression - on a vector by vector basis (vector/block size is defined
by the [block~] or [switch~] objects)., f 62;
#X text 514 14 These objects have several built in operators and functions.
The syntax is quite similar to how expressions are written in C. A
semicolon can be used to define and separate different expressions.
If so \, an outlet is created for each expression and they're evaluated
from right to left (or bottom to up) order:;
#X text 533 408 see also:;
#X obj 582 510 block~;
#X obj 641 510 value;
#N canvas 708 54 478 476 All_functions 0;
#N canvas 497 97 374 326 Arithmetic-operators 0;
#X obj 57 90 xnor/expr $f1 + 4;
#X floatatom 57 63 5 0 0 0 - - -, f 5;
#X floatatom 57 118 5 0 0 0 - - -, f 5;
#X floatatom 208 63 5 0 0 0 - - -, f 5;
#X floatatom 208 118 5 0 0 0 - - -, f 5;
#X obj 208 90 xnor/expr $f1 * 4;
#X floatatom 57 197 5 0 0 0 - - -, f 5;
#X floatatom 57 252 5 0 0 0 - - -, f 5;
#X floatatom 208 197 5 0 0 0 - - -, f 5;
#X floatatom 208 252 5 0 0 0 - - -, f 5;
#X obj 57 224 xnor/expr $f1 - 1;
#X obj 208 224 xnor/expr $f1 / 10;
#X text 57 34 Add;
#X text 206 34 Multiply;
#X text 206 174 Divide;
#X text 56 174 Subtract;
#X connect 0 0 2 0;
#X connect 1 0 0 0;
#X connect 3 0 5 0;
#X connect 5 0 4 0;
#X connect 6 0 10 0;
#X connect 8 0 11 0;
#X connect 10 0 7 0;
#X connect 11 0 9 0;
#X restore 147 131 pd Arithmetic-operators;
#N canvas 513 126 621 391 Bitwise-operators 0;
#X floatatom 47 218 5 0 0 0 - - -, f 5;
#X obj 47 188 xnor/expr ~ $f1;
#X floatatom 44 103 5 0 0 0 - - -, f 5;
#X obj 44 73 xnor/expr $f1 & 3;
#X floatatom 44 43 5 0 0 0 - - -, f 5;
#X text 104 41 Bitwise And;
#X floatatom 347 98 5 0 0 0 - - -, f 5;
#X floatatom 347 38 5 0 0 0 - - -, f 5;
#X obj 347 68 xnor/expr $f1 << 1;
#X floatatom 349 207 5 0 0 0 - - -, f 5;
#X floatatom 349 147 5 0 0 0 - - -, f 5;
#X text 404 147 Bitshift Right;
#X text 413 36 Bitshift Left;
#X obj 349 177 xnor/expr $f1 >> 2;
#X floatatom 353 320 5 0 0 0 - - -, f 5;
#X floatatom 353 260 5 0 0 0 - - -, f 5;
#X obj 353 290 xnor/expr $f1 ^ 1;
#X text 409 260 Bitwise Exclusive Or;
#X floatatom 52 324 5 0 0 0 - - -, f 5;
#X floatatom 52 264 5 0 0 0 - - -, f 5;
#X text 114 256 Bitwise Or;
#X obj 52 294 xnor/expr $f1 | 3;
#X floatatom 47 158 5 0 0 0 - - -, f 5;
#X text 97 155 Bitwise Not;
#X text 141 187 (one's complement);
#X connect 1 0 0 0;
#X connect 3 0 2 0;
#X connect 4 0 3 0;
#X connect 7 0 8 0;
#X connect 8 0 6 0;
#X connect 10 0 13 0;
#X connect 13 0 9 0;
#X connect 15 0 16 0;
#X connect 16 0 14 0;
#X connect 19 0 21 0;
#X connect 21 0 18 0;
#X connect 22 0 1 0;
#X restore 147 162 pd Bitwise-operators;
#N canvas 444 131 689 317 Comparison-operators 0;
#X floatatom 48 55 5 0 0 0 - - -, f 5;
#X floatatom 48 110 5 0 0 0 - - -, f 5;
#X floatatom 199 54 5 0 0 0 - - -, f 5;
#X floatatom 199 109 5 0 0 0 - - -, f 5;
#X floatatom 55 194 5 0 0 0 - - -, f 5;
#X floatatom 55 249 5 0 0 0 - - -, f 5;
#X floatatom 351 58 5 0 0 0 - - -, f 5;
#X floatatom 351 113 5 0 0 0 - - -, f 5;
#X obj 48 82 xnor/expr $f1 > 4;
#X obj 199 81 xnor/expr $f1 < 4;
#X obj 55 221 xnor/expr $f1 >= 1;
#X text 207 26 Less than;
#X text 48 26 Greater than;
#X text 50 148 Greater than;
#X text 57 166 or equal;
#X floatatom 203 195 5 0 0 0 - - -, f 5;
#X floatatom 203 250 5 0 0 0 - - -, f 5;
#X text 206 167 or equal;
#X text 202 149 Less than;
#X obj 203 222 xnor/expr $f1 <= 10;
#X text 356 25 Equal;
#X obj 351 85 xnor/expr $f1 == 2;
#X floatatom 497 58 5 0 0 0 - - -, f 5;
#X floatatom 497 113 5 0 0 0 - - -, f 5;
#X text 502 25 Not Equal;
#X obj 497 85 xnor/expr $f1 != 2;
#X floatatom 360 191 5 0 0 0 - - -, f 5;
#X floatatom 360 246 5 0 0 0 - - -, f 5;
#X text 365 158 Logical And;
#X obj 360 218 xnor/expr $f1 && 1;
#X floatatom 498 191 5 0 0 0 - - -, f 5;
#X floatatom 498 246 5 0 0 0 - - -, f 5;
#X text 503 158 Logical Or;
#X obj 498 218 xnor/expr $f1 || 0;
#X connect 0 0 8 0;
#X connect 2 0 9 0;
#X connect 4 0 10 0;
#X connect 6 0 21 0;
#X connect 8 0 1 0;
#X connect 9 0 3 0;
#X connect 10 0 5 0;
#X connect 15 0 19 0;
#X connect 19 0 16 0;
#X connect 21 0 7 0;
#X connect 22 0 25 0;
#X connect 25 0 23 0;
#X connect 26 0 29 0;
#X connect 29 0 27 0;
#X connect 30 0 33 0;
#X connect 33 0 31 0;
#X restore 147 193 pd Comparison-operators;
#N canvas 458 88 472 464 If-function 0;
#X floatatom 82 53 5 0 0 0 - - -, f 5;
#X floatatom 82 112 5 0 0 0 - - -, f 5;
#X floatatom 87 218 5 0 0 0 - - -, f 5;
#X floatatom 87 277 5 0 0 0 - - -, f 5;
#X text 142 213 if(condition \, true \, false);
#X obj 87 246 xnor/expr if($f1 > 0 \, $f1 * 10 \, $f1 - 1);
#X floatatom 59 346 5 0 0 0 - - -, f 5;
#X floatatom 59 405 5 0 0 0 - - -, f 5;
#X obj 59 374 xnor/expr if($f1 > 10 \, 10 \, if($f1 < -10 \, -10 \,
$f1));
#X text 118 404 <= clips at -10 and 10;
#X obj 82 81 xnor/expr if($f1 >= 0 \, 1 \, -1);
#X text 53 21 Syntax: if(condition \, true \, false);
#X text 143 325 You can also nest an if function as a true/false expression:
, f 32;
#X text 39 163 It accepts expressions as true/false as well:;
#X connect 0 0 10 0;
#X connect 2 0 5 0;
#X connect 5 0 3 0;
#X connect 6 0 8 0;
#X connect 8 0 7 0;
#X connect 10 0 1 0;
#X restore 147 226 pd If-function;
#N canvas 444 91 491 376 Random-function 0;
#X floatatom 107 206 5 0 0 0 - - -, f 5;
#X obj 107 175 xnor/expr random(10 \, 20);
#X obj 107 147 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X text 133 142 random values from 10 to 19;
#X floatatom 108 306 5 0 0 0 - - -, f 5;
#X obj 108 247 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 108 275 xnor/expr random(-100 \, 101);
#X text 134 242 random values from -100 to 100;
#X text 36 32 The random function generates random numbers within a
given range \, specified by the two arguments. The range is from the
first argument to the second argument minus one., f 51;
#X connect 1 0 0 0;
#X connect 2 0 1 0;
#X connect 5 0 6 0;
#X connect 6 0 4 0;
#X restore 147 257 pd Random-function;
#N canvas 437 97 594 434 Table-functions 0;
#X obj 63 73 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X floatatom 63 163 0 0 0 0 - - -;
#X floatatom 145 164 0 0 0 0 - - -;
#X floatatom 228 164 0 0 0 0 - - -;
#X text 28 101 Sum;
#X text 28 119 sum;
#X text 20 136 size;
#N canvas 0 50 450 300 (subpatch) 0;
#X array table 100 float 1;
#A 0 -0.714272 -0.678559 -0.642845 -0.607131 -0.571417 -0.52856 -0.485703
-0.428561 -0.371419 -0.314277 -0.257134 -0.228563 -0.114279 -0.0857077
-0.0571365 -0.0285654 5.72205e-06 0.0285769 0.0428624 0.057148 0.0857191
0.11429 0.142861 0.171432 0.171432 0.200004 0.200004 0.200004 0.228575
0.228575 0.228575 0.228575 0.228575 0.228575 0.228575 0.200004 0.0857191
5.72205e-06 -0.228563 -0.885699 -0.885699 -0.885699 -0.885699 -0.857128
-0.842843 -0.828557 -0.771415 -0.73332 -0.695225 -0.65713 -0.599988
-0.542846 -0.485703 -0.419038 -0.352372 -0.257134 -0.171421 -0.114279
5.72205e-06 0.0285769 0.142861 0.200004 0.228575 0.271431 0.314288
0.342859 0.400002 0.428573 0.485715 0.485715 0.514286 0.514286 0.514286
0.514286 0.514286 0.485715 0.457144 0.428573 0.428573 0.400002 0.342859
0.328574 0.314288 0.285717 0.285717 0.257146 0.257146 0.257146 0.257146
0.257146 0.257146 0.257146 0.285717 0.314288 0.342859 0.342859 0.342859
0.342859 0.342859 0.342859;
#X coords 0 1 99 -1 200 140 1 0 0;
#X restore 344 94 graph;
#X text 96 276 Note that the syntax requires that the table name is
inside quotes., f 51;
#X obj 295 347 xnor/expr size("$s1") \;;
#X obj 63 102 xnor/expr Sum("table" \, 3 \, 9) \; sum("table") \; size("table")
;
#X msg 295 317 symbol table;
#X floatatom 295 380 5 0 0 0 - - -, f 5;
#X text 64 187 Sums a range of indexes, f 8;
#X text 146 189 Sums all indexes, f 8;
#X text 225 189 Gives array size, f 5;
#X text 114 26 There are 3 functions that operate on arrays: Sum \,
sum and size., f 45;
#X connect 0 0 10 0;
#X connect 9 0 12 0;
#X connect 10 0 1 0;
#X connect 10 1 2 0;
#X connect 10 2 3 0;
#X connect 11 0 9 0;
#X restore 147 326 pd Table-functions;
#N canvas 576 55 618 571 Power-functions 0;
#X floatatom 74 60 5 0 0 0 - - -, f 5;
#X floatatom 74 119 5 0 0 0 - - -, f 5;
#X floatatom 74 151 5 0 0 0 - - -, f 5;
#X floatatom 74 208 5 0 0 0 - - -, f 5;
#X floatatom 71 337 5 0 0 0 - - -, f 5;
#X floatatom 71 409 0 0 0 0 - - -;
#X floatatom 338 103 5 0 0 0 - - -, f 5;
#X floatatom 426 101 5 0 0 0 - - -, f 5;
#X floatatom 338 31 5 0 0 0 - - -, f 5;
#X floatatom 340 414 5 0 0 0 - - -, f 5;
#X floatatom 340 484 0 0 0 0 - - -;
#X floatatom 74 513 5 0 0 0 - - -, f 5;
#X obj 74 88 xnor/expr pow($f1 \, 2);
#X text 42 88 pow;
#X text 33 178 sqrt;
#X text 41 364 exp;
#X floatatom 338 276 5 0 0 0 - - -, f 5;
#X floatatom 338 224 5 0 0 0 - - -, f 5;
#X obj 338 56 xnor/expr ln($f1) \; log($f1);
#X obj 74 484 xnor/expr fact($f1);
#X msg 74 451 3;
#X floatatom 435 482 0 0 0 0 - - -;
#X text 304 442 erf;
#X text 296 458 erfc;
#X floatatom 166 408 0 0 0 0 - - -;
#X floatatom 339 187 5 0 0 0 - - -, f 5;
#X floatatom 339 135 5 0 0 0 - - -, f 5;
#X obj 339 160 xnor/expr log1p($f1);
#X obj 338 249 xnor/expr log10($f1);
#X floatatom 341 375 5 0 0 0 - - -, f 5;
#X floatatom 341 323 5 0 0 0 - - -, f 5;
#X obj 341 348 xnor/expr ldexp($f1 \, 3);
#X text 310 57 ln;
#X text 302 70 log;
#X text 284 250 log10;
#X text 287 159 log1p;
#X text 290 348 ldexp;
#X text 36 482 fact;
#X obj 71 365 xnor/expr exp($f1) \; expm1($f1);
#X text 24 382 expm1;
#X floatatom 73 239 5 0 0 0 - - -, f 5;
#X floatatom 73 296 5 0 0 0 - - -, f 5;
#X text 33 268 cbrt;
#X obj 74 179 xnor/expr sqrt($f1);
#X obj 73 267 xnor/expr cbrt($f1);
#X text 183 382 exp - 1;
#X text 267 507 error function;
#X text 434 505 complementary error function, f 14;
#X obj 340 442 xnor/expr erf($f1) \; erfc($f1);
#X text 76 33 Raise to the power of;
#X text 141 148 Square root;
#X text 150 239 Cube root;
#X text 133 324 Exp: 'e' raised to the power of, f 15;
#X text 110 451 Factorial;
#X text 385 29 Natural log;
#X text 397 133 Natural log of input + 1;
#X text 385 221 Log base 10;
#X text 396 307 Multiply by integral power of 2, f 20;
#X text 400 409 Error functions;
#X text 124 54 second argument;
#X connect 0 0 12 0;
#X connect 2 0 43 0;
#X connect 4 0 38 0;
#X connect 8 0 18 0;
#X connect 9 0 48 0;
#X connect 12 0 1 0;
#X connect 17 0 28 0;
#X connect 18 0 6 0;
#X connect 18 1 7 0;
#X connect 19 0 11 0;
#X connect 20 0 19 0;
#X connect 26 0 27 0;
#X connect 27 0 25 0;
#X connect 28 0 16 0;
#X connect 30 0 31 0;
#X connect 31 0 29 0;
#X connect 38 0 5 0;
#X connect 38 1 24 0;
#X connect 40 0 44 0;
#X connect 43 0 3 0;
#X connect 44 0 41 0;
#X connect 48 0 10 0;
#X connect 48 1 21 0;
#X restore 147 359 pd Power-functions;
#N canvas 411 157 793 422 Trigonometric-functions 0;
#X floatatom 73 34 5 0 0 0 - - -, f 5;
#X floatatom 73 93 5 0 0 0 - - -, f 5;
#X floatatom 73 125 5 0 0 0 - - -, f 5;
#X floatatom 73 182 5 0 0 0 - - -, f 5;
#X floatatom 72 213 5 0 0 0 - - -, f 5;
#X floatatom 72 270 5 0 0 0 - - -, f 5;
#X obj 73 62 xnor/expr sin($f1);
#X text 38 62 sin;
#X text 35 152 cos;
#X obj 73 153 xnor/expr cos($f1);
#X text 35 242 tan;
#X obj 72 241 xnor/expr tan($f1);
#X floatatom 273 34 5 0 0 0 - - -, f 5;
#X floatatom 273 93 5 0 0 0 - - -, f 5;
#X floatatom 273 125 5 0 0 0 - - -, f 5;
#X floatatom 273 182 5 0 0 0 - - -, f 5;
#X text 231 62 asin;
#X text 228 152 acos;
#X obj 273 62 xnor/expr asin($f1);
#X obj 273 153 xnor/expr acos($f1);
#X text 122 32 sine;
#X text 124 125 cosine;
#X text 123 213 tangent;
#X floatatom 274 209 5 0 0 0 - - -, f 5;
#X floatatom 274 266 5 0 0 0 - - -, f 5;
#X obj 274 237 xnor/expr tan($f1);
#X text 230 238 atan;
#X text 340 32 arc sine;
#X text 335 125 arc cosine;
#X text 335 209 arc tangent;
#X floatatom 506 33 5 0 0 0 - - -, f 5;
#X floatatom 506 92 5 0 0 0 - - -, f 5;
#X floatatom 506 124 5 0 0 0 - - -, f 5;
#X floatatom 506 181 5 0 0 0 - - -, f 5;
#X floatatom 507 208 5 0 0 0 - - -, f 5;
#X floatatom 507 265 5 0 0 0 - - -, f 5;
#X text 454 61 asinh;
#X text 451 151 acosh;
#X text 453 237 atanh;
#X text 630 46 inverse hyperbolic sine, f 10;
#X obj 506 61 xnor/expr asinh($f1);
#X obj 506 152 xnor/expr acosh($f1);
#X obj 507 236 xnor/expr atanh($f1);
#X text 631 137 inverse hyperbolic cosine, f 10;
#X text 632 225 inverse hyperbolic tangent, f 10;
#X floatatom 243 319 5 0 0 0 - - -, f 5;
#X floatatom 243 376 5 0 0 0 - - -, f 5;
#X text 192 348 atan2;
#X obj 243 347 xnor/expr atan2($f1 \, $f2);
#X floatatom 380 319 5 0 0 0 - - -, f 5;
#X text 405 347 arc tangent of 2 variables;
#X connect 0 0 6 0;
#X connect 2 0 9 0;
#X connect 4 0 11 0;
#X connect 6 0 1 0;
#X connect 9 0 3 0;
#X connect 11 0 5 0;
#X connect 12 0 18 0;
#X connect 14 0 19 0;
#X connect 18 0 13 0;
#X connect 19 0 15 0;
#X connect 23 0 25 0;
#X connect 25 0 24 0;
#X connect 30 0 40 0;
#X connect 32 0 41 0;
#X connect 34 0 42 0;
#X connect 40 0 31 0;
#X connect 41 0 33 0;
#X connect 42 0 35 0;
#X connect 45 0 48 0;
#X connect 48 0 46 0;
#X connect 49 0 48 1;
#X restore 147 392 pd Trigonometric-functions;
#N canvas 172 121 1007 535 Other-functions 0;
#X floatatom 93 24 5 0 0 0 - - -, f 5;
#X floatatom 93 97 5 0 0 0 - - -, f 5;
#X text 202 52 convert to int;
#X floatatom 88 145 5 0 0 0 - - -, f 5;
#X floatatom 88 235 5 0 0 0 - - -, f 5;
#X text 58 51 int;
#X text 46 176 rint;
#X text 139 137 round a float to a nearby integer, f 17;
#X text 6 209 nearbyint;
#X text 141 289 convert to float;
#X floatatom 89 365 5 0 0 0 - - -, f 5;
#X floatatom 233 363 5 0 0 0 - - -, f 5;
#X floatatom 89 293 5 0 0 0 - - -, f 5;
#X text 37 323 float;
#X floatatom 421 30 5 0 0 0 - - -, f 5;
#X floatatom 421 106 5 0 0 0 - - -, f 5;
#X floatatom 537 103 5 0 0 0 - - -, f 5;
#X text 386 75 min;
#X text 386 58 max;
#X obj 421 58 xnor/expr max($f1 \, 0) \; min($f1 \, 0);
#X text 473 28 maximum / minimum;
#X obj 420 173 xnor/expr copysign($f1 \, $f2);
#X floatatom 578 150 5 0 0 0 - - -, f 5;
#X floatatom 420 148 5 0 0 0 - - -, f 5;
#X text 353 174 copysign;
#X floatatom 420 202 5 0 0 0 - - -, f 5;
#X text 466 201 copy sign of a number;
#X obj 89 318 xnor/expr float($i1) / 10 \; float(5) / 10 \;;
#X floatatom 732 162 5 0 0 0 - - -, f 5;
#X floatatom 841 161 5 0 0 0 - - -, f 5;
#X obj 732 117 xnor/expr isinf($f1) \; finite($f1);
#X text 683 116 isinf;
#X text 675 134 finite;
#X text 860 115 "is infinite" and "is finite", f 15;
#X floatatom 732 85 5 0 0 0 - - -, f 5;
#X msg 772 27 2;
#X obj 732 52 pow 1e+10;
#X msg 732 25 1;
#X floatatom 740 345 5 0 0 0 - - -, f 5;
#X floatatom 740 283 5 0 0 0 - - -, f 5;
#X obj 740 313 xnor/expr isnan($f1);
#X text 688 314 isnan;
#X text 861 293 "is Nan" (not a number), f 8;
#X text 372 296 modf;
#X floatatom 413 253 5 0 0 0 - - -, f 5;
#X floatatom 413 322 5 0 0 0 - - -, f 5;
#X text 365 280 imodf;
#X obj 93 52 xnor/expr int($f1) \; trunc($f1);
#X floatatom 188 97 5 0 0 0 - - -, f 5;
#X text 48 64 trunc;
#X text 202 67 truncate a float;
#X floatatom 139 235 5 0 0 0 - - -, f 5;
#X text 38 193 round;
#X floatatom 190 235 5 0 0 0 - - -, f 5;
#X obj 88 176 xnor/expr rint($f1) \; round($f1) \; nearbyint($f1);
#X text 471 400 float remainder functions, f 15;
#X floatatom 410 424 5 0 0 0 - - -, f 5;
#X floatatom 410 495 5 0 0 0 - - -, f 5;
#X floatatom 547 494 5 0 0 0 - - -, f 5;
#X floatatom 91 419 5 0 0 0 - - -, f 5;
#X floatatom 91 492 5 0 0 0 - - -, f 5;
#X floatatom 193 492 5 0 0 0 - - -, f 5;
#X text 143 417 ceil / floor;
#X text 47 447 ceil;
#X text 39 465 floor;
#X obj 91 447 xnor/expr ceil($f1) \; floor($f1);
#X obj 413 279 xnor/expr imodf($f1) \; modf($f1);
#X text 397 343 get signed integer, f 10;
#X text 507 345 get signed fractional, f 11;
#X floatatom 522 322 5 0 0 0 - - -, f 5;
#X floatatom 771 398 5 0 0 0 - - -, f 5;
#X obj 771 435 xnor/expr abs($f1);
#X text 739 435 abs;
#X floatatom 771 472 5 0 0 0 - - -, f 5;
#X text 819 397 absolute value;
#X text 369 452 fmod;
#X text 329 466 remainder;
#X obj 740 223 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 410 449 xnor/expr fmod($f1 \, 4.1) \; remainder($f1 \, 4.1)
;
#X msg 410 400 7;
#X obj 740 249 xnor/expr log(-1);
#X connect 0 0 47 0;
#X connect 3 0 54 0;
#X connect 12 0 27 0;
#X connect 14 0 19 0;
#X connect 19 0 15 0;
#X connect 19 1 16 0;
#X connect 21 0 25 0;
#X connect 22 0 21 1;
#X connect 23 0 21 0;
#X connect 27 0 10 0;
#X connect 27 1 11 0;
#X connect 30 0 28 0;
#X connect 30 1 29 0;
#X connect 34 0 30 0;
#X connect 35 0 36 0;
#X connect 36 0 34 0;
#X connect 37 0 36 0;
#X connect 39 0 40 0;
#X connect 40 0 38 0;
#X connect 44 0 66 0;
#X connect 47 0 1 0;
#X connect 47 1 48 0;
#X connect 54 0 4 0;
#X connect 54 1 51 0;
#X connect 54 2 53 0;
#X connect 56 0 78 0;
#X connect 59 0 65 0;
#X connect 65 0 60 0;
#X connect 65 1 61 0;
#X connect 66 0 45 0;
#X connect 66 1 69 0;
#X connect 70 0 71 0;
#X connect 71 0 73 0;
#X connect 77 0 80 0;
#X connect 78 0 57 0;
#X connect 78 1 58 0;
#X connect 79 0 56 0;
#X connect 80 0 39 0;
#X restore 147 424 pd Other-functions;
#N canvas 332 23 592 281 Store-function 0;
#X text 40 26 The store function is defined with "=" \, and it can
store the result of any operation into a variable or table index.;
#X obj 62 129 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X floatatom 62 211 5 0 0 0 - - -, f 5;
#X floatatom 276 204 5 0 0 0 - - -, f 5;
#X obj 62 158 xnor/expr array2[inc - 1] = 1 / inc \; inc = inc + 1
;
#N canvas 0 22 450 278 (subpatch) 0;
#X array array2 16 float 2;
#X coords 0 1.1 16 -0.1 200 140 1 0 0;
#X restore 351 101 graph;
#X obj 129 119 v inc;
#X msg 129 94 0;
#X connect 1 0 4 0;
#X connect 4 0 2 0;
#X connect 4 1 3 0;
#X connect 7 0 6 0;
#X restore 147 291 pd Store-function;
#X text 28 14 Here are all the operators and functions available for
[xnor/expr] \, [xnor/expr~] and [xnor/fexpr~] \, even though the given
examples are only presented with [xnor/expr]., f 52;
#X text 28 71 These are organized in different groups. Click on the
subpatches below to check each group:, f 52;
#X restore 803 432 pd All_functions \; and operators;
#N canvas 157 32 919 558 [xnor/expr] 0;
#X obj 49 115 xnor/expr 1;
#X floatatom 47 248 0 0 0 0 - - -;
#X floatatom 49 145 0 0 0 0 - - -;
#X msg 49 87 bang;
#X obj 150 115 xnor/expr 2 + 3;
#X msg 150 88 bang;
#X floatatom 150 143 0 0 0 0 - - -;
#X floatatom 47 309 0 0 0 0 - - -;
#X floatatom 69 402 0 0 0 0 - - -;
#X floatatom 69 478 0 0 0 0 - - -;
#X floatatom 700 156 0 0 0 0 - - -;
#X obj 700 128 xnor/expr 8 / 3;
#X floatatom 625 324 0 0 0 0 - - -;
#X obj 700 102 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 625 256 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X floatatom 566 505 0 0 0 0 - - -;
#X obj 566 477 xnor/expr $f1 / 3;
#X floatatom 693 503 0 0 0 0 - - -;
#X obj 693 475 xnor/expr $i1 / 3;
#X msg 693 434 8;
#X obj 693 404 loadbang;
#X text 17 27 Examples of [xnor/expr] object:;
#X text 248 107 bang evaluates the expression, f 17;
#X obj 47 278 xnor/expr ($f1 + 2) + $i2;
#X floatatom 184 249 0 0 0 0 - - -;
#X text 437 23 NOTE About integers:;
#X floatatom 748 324 0 0 0 0 - - -;
#X obj 625 280 xnor/expr float(8) / 3 \; 8./3;
#X text 121 400 use of trigonometric functions;
#X obj 69 430 xnor/expr cos(2 * 3.14159 * $f1 / 360) \; sin(2 * 3.14159
* $f1 / 360);
#X floatatom 304 478 0 0 0 0 - - -;
#X text 465 53 Integer numbers in the [xnor/expr] object are interpreted
as integers \, not floats. Hence \, the result of the division below
is also an integer.;
#X text 466 193 You can use the "float" function to convert an integer
to a float. Another workaround is to have a decimal point in a way
Pd can't turn into an integer \, such as below in the bottom expression:
;
#X text 222 242 '$f1' is a float from the 1st inlet \, '$i2' is an
integer from the second inlet (float input values are truncated to
integers), f 26;
#X text 475 365 But there's no issue if you send an integer value to
an inlet defined as a float.;
#X connect 0 0 2 0;
#X connect 1 0 23 0;
#X connect 3 0 0 0;
#X connect 4 0 6 0;
#X connect 5 0 4 0;
#X connect 8 0 29 0;
#X connect 11 0 10 0;
#X connect 13 0 11 0;
#X connect 14 0 27 0;
#X connect 16 0 15 0;
#X connect 18 0 17 0;
#X connect 19 0 16 0;
#X connect 19 0 18 0;
#X connect 20 0 19 0;
#X connect 23 0 7 0;
#X connect 24 0 23 1;
#X connect 27 0 12 0;
#X connect 27 1 26 0;
#X connect 29 0 9 0;
#X connect 29 1 30 0;
#X restore 557 268 pd [xnor/expr] Examples;
#N canvas 301 61 867 691 [xnor/expr~] 0;
#X floatatom 80 361 0 0 0 0 - - -;
#X obj 80 468 dac~;
#X text 125 361 frequency;
#X floatatom 685 260 0 0 10 0 - - -;
#X obj 478 329 tabsend~ a1;
#N canvas 0 50 450 300 (subpatch) 0;
#X array a1 64 float 0;
#X coords 0 1 63 -1 200 140 1;
#X restore 614 347 graph;
#X obj 88 631 tabsend~ a2;
#X obj 253 627 tabsend~ a3;
#N canvas 0 50 450 300 (subpatch) 0;
#X array a2 64 float 1;
#A 0 0.185293 0.247993 0.308949 0.36679 0.420237 0.468075 0.509197
0.542652 0.567606 0.583434 0.589671 0.586023 0.572438 0.549013 0.516069
0.474118 0.423808 0.366018 0.301731 0.232071 0.158273 0.0816412 0.00354935
-0.0746081 -0.151431 -0.225548 -0.295636 -0.360461 -0.418895 -0.469911
-0.512672 -0.54647 -0.570782 -0.585296 -0.589841 -0.584503 -0.569539
-0.545381 -0.512683 -0.472221 -0.424959 -0.371988 -0.314489 -0.253767
-0.191166 -0.128077 -0.0659013 -0.00601193 0.0502563 0.101646 0.146993
0.185262 0.215549 0.237114 0.249398 0.252013 0.244783 0.227713 0.20101
0.165078 0.120494 0.0680216 0.00857323 -0.0567935;
#X coords 0 1 63 -1 200 140 1;
#X restore 395 520 graph;
#N canvas 0 50 450 300 (subpatch) 0;
#X array a3 64 float 0;
#X coords 0 1 63 -1 200 140 1;
#X restore 617 520 graph;
#X obj 80 388 osc~ 440;
#X obj 283 332 hsl 128 15 0 127 0 0 empty empty empty -2 -8 0 10 -262144
-1 -1 0 1;
#X floatatom 280 352 5 0 0 0 - - -, f 5;
#X text 331 352 amplitude;
#X obj 280 399 line~;
#X obj 80 429 xnor/expr~ $v1 * pow($v2 / 127 \, 4);
#X obj 88 581 xnor/expr~ $v1 * $v2 \; if ($v2 > 0 \, 0 \, $v1*$v2)
;
#X obj 88 548 osc~ 440;
#X obj 478 252 osc~ 440;
#X msg 322 52 \; pd dsp 0;
#X msg 229 52 \; pd dsp 1;
#X text 227 30 audio on;
#X text 320 29 audio off;
#X obj 478 290 xnor/expr~ max(min($v1 \, $f2) \, -$f2);
#X obj 685 145 vsl 20 100 0 1 0 0 empty empty empty 0 -9 0 10 -262144
-1 -1 0 1;
#X text 460 187 Move the slider to change the limiter threshold (from
0-1)., f 29;
#X text 64 29 make sure to turn on the audio for the [xnor/expr~] examples
====>, f 23;
#X obj 130 297 print~;
#X msg 148 268 bang;
#X floatatom 232 207 0 0 0 0 - - -;
#X floatatom 130 182 0 0 0 0 - - -;
#X obj 130 237 xnor/expr~ $v1 + $f2;
#X obj 130 209 sig~ 1;
#X obj 253 548 osc~ 550;
#X text 458 163 A simple limiter/clip example:;
#X text 27 202 Examples:;
#X text 468 37 NOTE: The vector/block size can be set with the [block~]
or [switch~] objects \, and is 64 samples by default., f 43;
#X msg 280 375 \$1 20;
#X text 22 111 NOTE: The first inlet of [xnor/expr~] needs to be of
type '$v1' (cannot be '$f1' \, '$i1' or '$s1'). A float sent to a '$v#'
inlet is promoted to a signal., f 54;
#X connect 0 0 10 0;
#X connect 3 0 23 1;
#X connect 10 0 15 0;
#X connect 11 0 12 0;
#X connect 12 0 37 0;
#X connect 14 0 15 1;
#X connect 15 0 1 0;
#X connect 15 0 1 1;
#X connect 16 0 6 0;
#X connect 16 1 7 0;
#X connect 17 0 16 0;
#X connect 18 0 23 0;
#X connect 23 0 4 0;
#X connect 24 0 3 0;
#X connect 28 0 27 0;
#X connect 29 0 31 1;
#X connect 30 0 32 0;
#X connect 31 0 27 0;
#X connect 32 0 31 0;
#X connect 33 0 16 1;
#X connect 37 0 14 0;
#X restore 549 296 pd [xnor/expr~] Examples;
#N canvas 140 26 977 725 [xnor/fexpr~] 0;
#X msg 339 45 \; pd dsp 0;
#X msg 246 45 \; pd dsp 1;
#X text 244 23 audio on;
#X text 337 22 audio off;
#X text 41 387 - $x1: same as $x1[0] \, $x2: same as $x2[0] (and so
on)., f 60;
#X text 41 368 - $x: same as $x1[0]., f 60;
#X text 41 406 - $y: same as $y1[-1]., f 60;
#X text 41 426 - $y1: same as $y1[-1] \, $y2: same as $y2[-1] (and
so on)., f 60;
#X msg 112 538 start;
#X msg 60 538 stop;
#X obj 60 508 loadbang;
#X msg 181 535 set 4000;
#X obj 168 501 sig~ 0.001;
#X obj 168 603 xnor/fexpr~ $x1[0] + $y1[-1];
#X msg 195 569 clear y1;
#X text 262 569 clears output buffer;
#X obj 168 641 snapshot~;
#X obj 32 593 metro 100;
#X obj 32 571 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 1
1;
#X floatatom 168 673 0 0 0 0 - - -;
#X text 248 500 increment value;
#X text 246 534 set last output value ($y1[-1]);
#X text 506 233 - clear: clears all the previous input and output buffers
, f 60;
#X text 506 194 - clear x#: clears the previous values of the #th input
, f 60;
#X text 506 213 - clear y#: clears the previous values of the #th output
, f 60;
#X text 506 87 - set y# <list>: sets the as many supplied values of
the #th output (e.g. "set y3 1 2" sets $y3[-1] = 1 and $y3[-2] = 2).
;
#X floatatom 767 549 0 0 0 0 - - -;
#X msg 568 515 start;
#X msg 522 515 stop;
#X obj 522 482 loadbang;
#X msg 728 511 0;
#X obj 598 670 dac~;
#X obj 623 624 *~ 0.1;
#X obj 623 585 xnor/fexpr~ $x1 + $x1[$f2];
#X msg 623 457 1102.5;
#X floatatom 623 515 0 0 0 0 - - -;
#X text 502 382 Simple FIR filter:, f 61;
#X msg 807 511 -20;
#X msg 767 511 -10;
#X text 705 465 change values to filter the frequencies, f 23;
#X text 506 131 - set <list>: sets the first past values of each output
(e.g. "set 0.1 2.2 0.4" sets y1[-1] = 0.1 \, y2[-1] = 2.2 \, and y3[-1]
= 0.4).;
#X text 506 42 - set x# <list>: sets as many supplied values of the
#th input (e.g. "set x2 1 2" sets $x2[0] = 1 and $x2[-1] = 2)., f
60;
#X text 14 93 NOTES:;
#X text 14 460 Simple accumulator example:;
#X text 482 13 [xnor/fexpr~] responds to the following methods:, f
63;
#X text 62 234 - $y#[n]: output sample of outlet # indexed by 'n';
#X text 62 215 - $x#[n]: input sample of inlet # indexed by 'n', f
50;
#X text 24 346 - There are shorthands as follows:;
#X text 506 252 - stop: stops the computation of [xnor/fexpr~] *,
f 60;
#X text 506 272 - start: starts the computation of [xnor/fexpr~] *
, f 60;
#X text 835 615 more examples:;
#N canvas 286 64 900 597 Difference 0;
#X obj 194 193 v pr;
#X obj 341 193 v r;
#X obj 249 195 v b;
#X floatatom 194 164 5 0 0 0 - - -, f 5;
#X floatatom 341 166 5 0 0 0 - - -, f 5;
#X msg 194 139 10;
#X msg 172 251 set 1.2 2.3 4.4;
#X floatatom 249 165 7 0 0 0 - - -, f 7;
#X floatatom 399 166 5 0 0 0 - - -, f 5;
#X obj 399 195 v dt;
#X msg 341 137 18;
#X msg 399 127 0.01;
#X obj 79 400 dac~;
#X obj 172 65 bng 25 250 50 0 empty empty empty 20 8 0 8 -262144 -1
-1;
#X obj 449 136 line;
#X msg 449 110 0.01 \, 0.04 5000;
#X obj 101 193 loadbang;
#N canvas 0 50 450 300 (subpatch) 0;
#X array X 64 float 0;
#X coords 0 20 63 -20 200 140 1 0 0;
#X restore 178 423 graph;
#N canvas 0 50 450 300 (subpatch) 0;
#X array Y 64 float 0;
#X coords 0 20 63 -20 200 140 2 0 0;
#X restore 418 421 graph;
#N canvas 0 50 450 300 (subpatch) 0;
#X array Z 64 float 0;
#X coords 0 40 63 0 200 140 2 0 0;
#X restore 655 420 graph;
#X obj 249 136 xnor/expr 8./3;
#X text 577 289 $y1 -> $y1[-1] $y2 -> $y2[-1] $y3 -> $y3[-1], f 15
;
#X obj 94 359 *~ 0.01;
#X text 145 547 -20;
#X text 152 416 20;
#X text 381 547 -20;
#X text 388 416 20;
#X text 635 547 0;
#X text 630 416 40;
#X text 624 24 Lorenz Equations written with 3 state variables X \,
Y \, and Z:, f 30;
#X text 412 301 <= Note the shorthands:;
#X text 670 67 dX/dt = pr * (Y - X);
#X text 670 87 dY/dt = X(r - Z) - Y;
#X text 670 107 dZ/dt = X*Y - bZ, f 20;
#X obj 172 285 xnor/fexpr~ $y1 + pr*($y2 - $y1) * dt \; $y2 + ($y1*(r
- $y3) - $y2) * dt \; $y3 + ($y1*$y2 - b*$y3) * dt;
#X obj 172 359 tabsend~ X;
#X obj 286 359 tabsend~ Y;
#X obj 400 360 tabsend~ Z;
#X text 294 250 <= sets initial values of $y1[-1] \, $y2[-1] \, and
$y3[-1];
#X msg 23 220 start \; pd dsp 1;
#X text 108 51 bang to start =>, f 8;
#X text 228 24 This is an example of how [xnor/fexpr~] can be used
to solve differential equations such as the lorenz equations., f 49
;
#X msg 101 218 stop;
#X text 446 165 <= experiment with these parameter values. If you;
#X text 470 183 hear a click and audio stops \, the system went unstable
and you need to bang on the top again to reload the default values.
, f 46;
#X connect 3 0 0 0;
#X connect 4 0 1 0;
#X connect 5 0 3 0;
#X connect 6 0 34 0;
#X connect 7 0 2 0;
#X connect 8 0 9 0;
#X connect 10 0 4 0;
#X connect 11 0 8 0;
#X connect 13 0 5 0;
#X connect 13 0 10 0;
#X connect 13 0 11 0;
#X connect 13 0 6 0;
#X connect 13 0 39 0;
#X connect 13 0 20 0;
#X connect 14 0 8 0;
#X connect 15 0 14 0;
#X connect 16 0 42 0;
#X connect 20 0 7 0;
#X connect 22 0 12 0;
#X connect 22 0 12 1;
#X connect 34 0 22 0;
#X connect 34 0 35 0;
#X connect 34 1 36 0;
#X connect 34 2 37 0;
#X connect 39 0 34 0;
#X connect 42 0 34 0;
#X restore 708 669 pd Difference equations (Lorenz);
#X text 25 262 'n' goes from 0 to -vector size (defined by the [block~]
or [switch~] objects). As such \, $x#[0] specifies the current sample
input \, and $y#[-1] the last sample output (which is the minimum 'n'
value \, for $y#).;
#X text 79 24 make sure to turn on the audio for the [xnor/fexpr~]
examples ====>, f 23;
#X text 548 299 * [xnor/fexpr~] can be CPU expensive! By default \,
[xnor/fexpr~] is on when it is loaded \, but you can save CPU and control
when it is on or off with the 'start' and 'stop' messages., f 54;
#N canvas 695 185 491 366 Fractional 0;
#X msg 120 179 start;
#X msg 68 178 stop;
#X obj 68 147 loadbang;
#X obj 140 329 dac~;
#X obj 151 288 *~ 0.1;
#X obj 298 136 hsl 128 15 0 -10 0 0 empty empty empty -2 -8 0 10 -262144
-1 -1 0 1;
#X floatatom 295 162 0 -10 0 0 - - -;
#X obj 295 222 line~;
#X msg 295 192 \$1 100;
#X obj 151 253 xnor/fexpr~ $x1 + $x1[$X2];
#X obj 151 211 osc~ 2205;
#X text 194 116 fractional sample index offset, f 17;
#X text 25 16 When fractional index offset is used for either input
or output samples \, [xnor/fexpr~] determines the value by linear interpolation.
, f 63;
#X text 25 57 In the following example \, you can continuously change
the sample input index from 0 to -10 (which filters the frequency of
2205)., f 63;
#X connect 0 0 9 0;
#X connect 1 0 9 0;
#X connect 2 0 1 0;
#X connect 4 0 3 0;
#X connect 4 0 3 1;
#X connect 5 0 6 0;
#X connect 6 0 8 0;
#X connect 7 0 9 1;
#X connect 8 0 7 0;
#X connect 9 0 4 0;
#X connect 10 0 9 0;
#X restore 756 641 pd Fractional sample index;
#X text 555 404 -10 offset filters audio at frequency of 2205 Hz -20
offset filters audio at frequency of 1102.5 Hz, f 50;
#X msg 640 484 2205;
#X obj 623 546 osc~ 2205;
#X text 25 121 - The first inlet of [xnor/fexpr~] only accepts signals
and needs to be '$x1' (cannot be '$f1' \, '$i1' or '$s1'). Other than
that \, a float sent to a '$v#' inlet is promoted to a signal.;
#X text 25 174 - [xnor/fexpr~] does not understand '$v#' variables
from [xnor/expr~] \, it has its special input and output variables
defined as:;
#X connect 8 0 13 0;
#X connect 9 0 13 0;
#X connect 10 0 9 0;
#X connect 10 0 18 0;
#X connect 11 0 13 0;
#X connect 12 0 13 0;
#X connect 13 0 16 0;
#X connect 14 0 13 0;
#X connect 16 0 19 0;
#X connect 17 0 16 0;
#X connect 18 0 17 0;
#X connect 26 0 33 1;
#X connect 27 0 33 0;
#X connect 28 0 33 0;
#X connect 29 0 28 0;
#X connect 30 0 26 0;
#X connect 32 0 31 0;
#X connect 32 0 31 1;
#X connect 33 0 32 0;
#X connect 34 0 35 0;
#X connect 35 0 58 0;
#X connect 37 0 26 0;
#X connect 38 0 26 0;
#X connect 57 0 35 0;
#X connect 58 0 33 0;
#X restore 541 324 pd [xnor/fexpr~] Examples;
#X obj 804 238 print xnor/expr;
#X obj 714 458 +;
#X obj 714 483 +~;
#X obj 714 433 >;
#X text 573 434 binary operators:;
#X text 545 458 arithmetic operators:;
#X text 580 483 audio operators:;
#X text 561 206 (click on the subpatches to open them), f 13;
#X obj 694 510 random;
#X text 796 517 updated for Pd 0.48-1;
#N canvas 175 30 885 622 [value] 0;
#X floatatom 596 202 5 0 0 0 - - -, f 5;
#X obj 596 137 until;
#X msg 719 138 0;
#X obj 719 168 v i;
#X obj 596 169 xnor/expr i = i + 1;
#X msg 596 72 10;
#X obj 596 229 print;
#X obj 261 63 loadbang;
#X obj 221 176 value a;
#X obj 261 149 value b;
#X obj 304 123 value c;
#X obj 91 337 xnor/expr (a + b) / c;
#X obj 91 310 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X floatatom 91 371 0 0 0 0 - - -;
#X obj 596 103 trigger float bang;
#X text 22 15 The xnor/expr family of objects can access variables
set into [value] objects.;
#X obj 697 302 xnor/expr i * 2 \; i = i + 1;
#X floatatom 697 348 5 0 0 0 - - -, f 5;
#X floatatom 771 349 5 0 0 0 - - -, f 5;
#X obj 697 267 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X text 33 233 All you have to do is just use the variable name into
the expression:, f 27;
#X obj 90 422 xnor/expr~ (a + b) / c;
#X obj 90 453 print~;
#X obj 62 421 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X msg 221 97 5;
#X msg 261 97 3;
#X msg 304 97 2.5;
#X obj 91 533 print~;
#X obj 63 501 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 91 502 xnor/fexpr~ (a + b) / c;
#X text 325 305 Expressions are output from right to left order in
[xnor/expr] \, since they're evaluated from bottom to top. This means
you need to update a variable and call it in the above expression \,
check it =============>, f 51;
#X obj 729 478 v last;
#X obj 603 509 xnor/fexpr~ last = $x1[-1] \; $x1[0] - last;
#X obj 754 564 print~;
#X obj 788 529 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 603 478 phasor~ 1000;
#X text 100 98 loading values into [value] objects =======>, f 16
;
#X text 471 14 It is also possible to assign values to variables inside
the xnor/expr family of objects with "=" ("store function")., f 54
;
#X text 325 401 You cannot assign variables values in [xnor/expr~]
because it deals with signal vectors and not single values. On the
other hand \, [xnor/fexpr~] can assign values to variables \, but they're
evaluated in from top to bottom instead. This means you need to update
a variable and call it in the below expression \, check it:, f 68
;
#X connect 0 0 6 0;
#X connect 1 0 4 0;
#X connect 2 0 3 0;
#X connect 4 0 0 0;
#X connect 5 0 14 0;
#X connect 7 0 25 0;
#X connect 7 0 26 0;
#X connect 7 0 24 0;
#X connect 11 0 13 0;
#X connect 12 0 11 0;
#X connect 14 0 1 0;
#X connect 14 1 2 0;
#X connect 16 0 17 0;
#X connect 16 1 18 0;
#X connect 19 0 16 0;
#X connect 21 0 22 0;
#X connect 23 0 22 0;
#X connect 24 0 8 0;
#X connect 25 0 9 0;
#X connect 26 0 10 0;
#X connect 28 0 27 0;
#X connect 29 0 27 0;
#X connect 32 1 33 0;
#X connect 34 0 33 0;
#X connect 35 0 32 0;
#X restore 803 378 pd [value];
#X text 20 16 Expression evaluation family of objects:, f 62;
#X obj 226 13 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X connect 3 0 16 0;
#X connect 4 0 37 0;
#X connect 5 0 37 0;
#X connect 16 0 4 0;
#X connect 16 1 5 0;
#X connect 16 2 17 0;
#X connect 17 0 37 0;
#X connect 49 0 0 0;
